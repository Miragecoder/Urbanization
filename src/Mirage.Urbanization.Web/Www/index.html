<!DOCTYPE html>
<html>
<head>
    <title>Urbanization</title>
    <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/icons/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/icons/favicon-194x194.png" sizes="194x194">
    <link rel="icon" type="image/png" href="/icons/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/icons/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/icons/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/icons/manifest.json">
    <link rel="shortcut icon" href="/icons/favicon.ico">
    <meta name="msapplication-TileColor" content="#2b5797">
    <meta name="msapplication-TileImage" content="/icons/mstile-144x144.png">
    <meta name="msapplication-config" content="/icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">

    <style type="text/css">
        body {
            margin: 0;
            background-color: BurlyWood;
        }

        .header-container {
            width: 100%;
            position: fixed;
            top: 0;
            text-align: left;
        }

        #buttonBar {
            height: 50px;
            width: 100%;
            margin: 0 auto;
            text-align: left;
        }
    </style>
</head>

<body>
    <div class="header-container">
        <div id="buttonBar">
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <!--Script references. -->
    <!--Reference the jQuery library. -->
    <script src="Scripts/jquery-1.6.4.min.js"></script>
    <!--Reference the SignalR library. -->
    <script src="Scripts/jquery.signalR-2.2.0.min.js"></script>
    <!--Reference the autogenerated SignalR hub script. -->
    <script src="signalr/hubs"></script>
    <!--Add script to update the page and send messages.-->
    <script type="text/javascript">
        var zoneInfos = {};
        $(function () {
            var simulation = $.connection.simulationHub;
            var buttonDefinitionStates = {};
            var currentButton = null;
            var imageCache = {};
            var canvas = document.getElementById('gameCanvas');

            var persistZoneInfo = function (zoneInfo) {
                zoneInfos[zoneInfo.key] = zoneInfo;
                zoneInfos[zoneInfo.key].drawn = false;
            };

            var drawZoneInfoForBitmapLayer = function (zoneInfo, selectBitmapLayer) {
                var context = canvas.getContext('2d');
                if (imageCache.hasOwnProperty(selectBitmapLayer(zoneInfo)) && imageCache[selectBitmapLayer(zoneInfo)] !== null) {
                    context.drawImage(imageCache[selectBitmapLayer(zoneInfo)], zoneInfo.point.x * 25, zoneInfo.point.y * 25);
                } else {
                    var tileImage = new Image();
                    tileImage.src = '/tile/' + selectBitmapLayer(zoneInfo);
                    tileImage.onload = function () {
                        context.drawImage(tileImage, zoneInfo.point.x * 25, zoneInfo.point.y * 25);
                        imageCache[selectBitmapLayer(zoneInfo)] = tileImage;
                    };
                }
            };

            var drawZoneInfo = function (zoneInfo) {

                if (canvas.width < zoneInfo.point.x * 25)
                    canvas.width = zoneInfo.point.x * 25;
                if (canvas.height < zoneInfo.point.y * 25)
                    canvas.height = zoneInfo.point.y * 25;

                if (zoneInfo.bitmapLayerOne !== 0) {
                    drawZoneInfoForBitmapLayer(zoneInfo, function (x) { return x.bitmapLayerOne; });
                    if (zoneInfo.bitmapLayerTwo !== 0) {
                        drawZoneInfoForBitmapLayer(zoneInfo, function (x) { return x.bitmapLayerTwo; });
                    }
                } else {
                    var context = canvas.getContext('2d');
                    context.beginPath();
                    context.fillStyle = zoneInfo.color;
                    context.rect(zoneInfo.point.x * 25, zoneInfo.point.y * 25, 25, 25);
                    context.fill();
                }

                zoneInfo.drawn = true;
            };

            simulation.client.submitAndDraw = function (zoneInfo) {
                persistZoneInfo(zoneInfo);
                drawZoneInfo(zoneInfo);
            };

            simulation.client.submitZoneInfos = function (zoneInfos) {
                for (var i in zoneInfos) {
                    if (zoneInfos.hasOwnProperty(i)) {
                        var zoneInfo = zoneInfos[i];
                        persistZoneInfo(zoneInfo);
                        drawZoneInfo(zoneInfo);
                    }
                }
            };

            simulation.client.submitMenuStructure = function (incomingButtonDefinitions) {
                console.log('Invocation of submitMenuStructure');
                (function () {
                    for (var p in incomingButtonDefinitions) {
                        if (incomingButtonDefinitions.hasOwnProperty(p)) {
                            var incomingButtonDefinition = incomingButtonDefinitions[p];
                            if (typeof (buttonDefinitionStates[incomingButtonDefinition.name]) === typeof (undefined)) {
                                buttonDefinitionStates[incomingButtonDefinition.name] = {
                                    buttonDefinition: incomingButtonDefinition,
                                    drawn: false
                                };
                            }
                        }
                    }
                })();

                for (var i in buttonDefinitionStates) {
                    if (buttonDefinitionStates.hasOwnProperty(i)) {
                        var buttonDefinitionState = buttonDefinitionStates[i];
                        var buttonBar = document.getElementById('buttonBar');
                        if (!buttonDefinitionState.drawn) {
                            var newButtonElement = document.createElement('button');
                            newButtonElement.innerHTML = buttonDefinitionState.buttonDefinition.name;
                            buttonBar.appendChild(newButtonElement);

                            var registerButton = function (inputButtonDefinition) {
                                var x = inputButtonDefinition;
                                return function () {
                                    currentButton = x.buttonDefinition;
                                };
                            }
                            newButtonElement.addEventListener('click', registerButton(buttonDefinitionState));

                            buttonDefinitionState.drawn = true;
                        }
                    }
                }
            };

            $.connection.hub.start().done(function () {

                console.log('Hub started succesfully. Initiating post-hub startup phase...');

                function getMousePos(canvas, evt) {
                    var rect = canvas.getBoundingClientRect();
                    return {
                        x: evt.clientX - rect.left,
                        y: evt.clientY - rect.top
                    };
                }

                var currentFocusedCell = { x: 0, y: 0 };

                canvas.addEventListener('mousemove', function (evt) {
                    var mousePos = getMousePos(canvas, evt);
                    currentFocusedCell = { x: Math.floor(mousePos.x / 25), y: Math.floor(mousePos.y / 25) };
                }, false);

                canvas.addEventListener('click', function () {
                    if (currentButton !== null) {
                        simulation.server.consumeZone(currentButton.name, currentFocusedCell.x, currentFocusedCell.y);
                    }
                });

                simulation.server.requestMenuStructure();
                console.log('Post-hub startup phase completed.');
            });
        });
    </script>
</body>
</html>